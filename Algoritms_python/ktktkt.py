"""
КТ динамическое програмипрование 

Решим задачу методом динамического программирования. 
Целевая функция - F(i,j) - количество путей коня из начальной клетки в клетку (i,j). 
В клетку (i,j) можно прийти из клеток (i−1,j−2) и (i−2,j−1), 
поэтому F(i,j)=F(i−1,j−2)+F(i−2,j−1). 
Начальное значение - F(n,m)=1. 
В качестве ответа необходимо вывести значение F(n,m).
Для обработки крайних клеток доски удобно ввести каемочку — строку и столбец с номером 0. 
При этом ширина каемочки должна быть две клетки, 
так как при вычислении значения функции приходится вычитать 2 из номера строки и номера столбца. 
В качестве второй строки (столбца) каемочки будет использоваться строка и столбец с номером 1 — они все заполнены нулями, 
кроме начальной клетки.

Пусть dp[i][j] содержит количество способов, 
которыми можно добраться из левого верхнего угла – клетки с координатами (1, 1) в правый нижний угол – клетку с координатами (n, m).
 Изначально обнулим массив dp и положим dp[1][1] = 1.

Согласно ходам коня в клетку (i, j) можно попасть либо из (i – 1, j – 2), 
либо из (i – 2, j – 1). Следовательно

dp[i][j] = dp[i – 1][j – 2] + dp[i – 2][j – 1]
"""


n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list([-1 for j in range(m)]))
a[0][0] = 1
# print(a)


def sol(i, j):
    if i >= 0 and j >= 0 and i < n and j < m:
        if a[i][j] == -1:
            a[i][j] = sol(i-2, j-1)+sol(i-2, j+1)+sol(i-1, j-2)+sol(i+1, j-2)
    else:
        return 0
    print(a)
    return a[i][j]


print(sol(n-1, m-1))













